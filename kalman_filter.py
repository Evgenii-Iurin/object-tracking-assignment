import numpy as np

class KalmanFilter2D:
    """
    :param x: Initial x position
    :param y: Initial y position
    :param dt: Time step (default is 1.0)
    
    **Состояние**
    Состояние состоит из 4 переменных: 
        
        ```
            x - позиция по x
            y - позиция по y
            vx - скорость по x
            vy - скорость по y
        ```
    В начале состояние инициализируется с нулевой скоростью.
     
    **Матрица Перехода A**
        Note : В зависимости от источника - эта матрица может обозначаться как F
        
        Эта матрица описывает, как меняется состояние системы от кадра к кадру, 
        если нет никакого нового измерения (то есть чисто по модели движения)
        
        На самом деле - это просто матрица, которая образывает систему уравнений
        
        ```
        x(k) = A * x(k-1)
        ```
        
        где x - это вектор состояния, а A - это матрица перехода.
        
        ```
        x(k) = x(k-1) + vx(k-1) * dt
        y(k) = y(k-1) + vy(k-1) * dt
        ```

        Это простая модель равномерного прямолинейного движения (constant velocity model).


    **Матрица Наблюдения H**
        Она определяет, какую часть состояния мы реально "видим" через измерения. Это означает: 
        "мы измеряем только координаты `x` и `y`, но не скорость" , потому что каждая детекия
        возвращает только координаты `x` и `y` bounging box'a.
        
        После перемножения матрицы H на вектор состояния x, мы получаем только координаты `x` и `y`:
        ```
        z(k) = H * x(k)
        ```
        
    **P - ковариационная матрица ошибки состояния**:
    
        ```
        P = np.eye(4) * 500
        ```
        Начальная неопределенность: большие значения означают, что фильтр изначально мало знает об объекте.

    **Q - шум модели (process noise)**:

        ```
        Q = np.eye(4) * 1
        ```
        Определяет, насколько движения объекта могут быть нестабильными (например, рывки, ускорения).

    **R — шум измерения (measurement noise)**:
        ```
        R = np.eye(2) * 10
        ```
        Указывает, насколько шумными являются внешние измерения (например, координаты из детектора объектов).

     
    
    """ 
    def __init__(self, x, y):
        self.dt = 1.0
        
        # Состояние: x, y, vx, vy
        self.x = np.array([[x], [y], [0], [0]])

        self.A = np.array([
            [1, 0, self.dt, 0],
            [0, 1, 0, self.dt],
            [0, 0, 1, 0],
            [0, 0, 0, 1]
        ])
        
        self.H = np.array([
            [1, 0, 0, 0],
            [0, 1, 0, 0]
        ])
        
        self.P = np.eye(4) * 500  # Начальная неопределенность
        self.Q = np.eye(4) * 1    # Шум движения
        self.R = np.eye(2) * 10   # Шум измерения

    def predict(self) -> np.ndarray:
        """
        отвечает за экстраполяцию состояния вперёд во времени, 
        то есть за предсказание, где сейчас должен находиться 
        объект, если никаких новых измерений не поступило
        
        ```
        self.x = self.A @ self.x
        ```
        
        Это предсказание нового состояния объекта по модели движения.
        Пример: если объект движется вправо со скоростью 2 м/с, то через 1 секунду он будет на 2 метра правее.
        На основе предыдущей позиции и скорости, мы вычисляем, где объект должен быть сейчас, если не поступило измерения.
        
        ```
        self.P = self.A @ self.P @ self.A.T + self.Q
        ```
        
        Мы обновляем уверенность в нашем предсказанном состоянии
        Даже если модель движения идеальна, на практике объект может:
            слегка ускориться,
            изменить направление,
            дернуться (например, из-за помех)
            
        Поэтому мы увеличиваем ковариацию (неуверенность), добавляя self.Q.
        Это означает: "Мы предсказали, но мы не на 100% уверены, где он на самом деле."
        """
        self.x = self.A @ self.x
        self.P = self.A @ self.P @ self.A.T + self.Q
        return self.x[:2].flatten()  # только позиция

    def update(self, z):
        """
        Метод выполняет коррекцию предсказанного состояния,
        используя новое внешнее измерение `z` (координаты центра объекта из bbox)
        
        Что-то в стиле : "Я предсказал, где объект должен быть... A вот пришло 
        измерение - теперь уточню своё мнение, учитывая два источника."
        
        **1. координаты из детекции**
        
        ```
        z = np.array(z).reshape((2, 1))
        ```
        
        **2.  Innovation (новизна)**
        y - разница между измерением и предсказанным положением.
        H@x - извлекает предсказанную позицию из полного состояния.
        Это похоже на: "Я предсказал, что объект здесь, a измерение говорит — нет, он там." 
            --> Как сильно они расходятся?
        Это что-то в стиле ошибки предсказания. У нас есть grand truth (измерение - Z) и предсказание.
        
        ```
        y = z - self.H @ self.x
        ```
        
        **3.  Innovation covariance - неопределённость новизны**
        
        Насколько "надежной" является разница y? 
        Считается как сумма: неопределённости предсказания (P) и шума измерения (R) 
        Это влияет на долю доверия к измерению.
        
        ```
        S = self.H @ self.P @ self.H.T + self.R
        ```
        
        **4.  Коэффициент Калмана K**
        Показывает, сколько из измерения взять в новую оценку.
        Если фильтр уверен --> K маленький.
        Если измерение точное, но фильтр не уверен  --> K большой.
        Это баланс между: моделью (predict) и реальным измерением (update)

        ```
        K = self.P @ self.H.T @ np.linalg.inv(S)
        ```
        
        **5. Обновление состояния**
        Мы корректируем предсказанное состояние в сторону измерения
        Насколько сильно - зависит от коэффициента Калмана
        Например:  
            "Я думал, что объект на (105, 100), 
            но измерение говорит (100, 100), и я доверяю измерению на 70%
            --> тогда новое положение будет 103.5"
        
        ```
        self.x = self.x + K @ y
        ```
        
        **6.  Обновление ковариации ошибки**
        После того как мы уточнили положение, наша уверенность 
            в состоянии увеличилась --> неопределённость уменьшается
        Эта строка как бы говорит: 
            "Теперь я уверен больше, потому что получил хорошее измерение"
        
        ```
        self.P = (np.eye(4) - K @ self.H) @ self.P
        ```
        
        Фильтр предсказал, где объект находится, но теперь он получил измерение и 
        не просто заменяет старое значение, а комбинирует его с измерением с 
        учётом вероятностной уверенности.

        """
        z = np.array(z).reshape((2, 1))
        y = z - self.H @ self.x
        S = self.H @ self.P @ self.H.T + self.R
        K = self.P @ self.H.T @ np.linalg.inv(S)
        self.x = self.x + K @ y
        self.P = (np.eye(4) - K @ self.H) @ self.P
